{"version":3,"sources":["../src/cli.ts","../src/index.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { Command } from 'commander'\nimport { startSink } from './index.js'\n\nconst program = new Command()\n  .name('smtp-sink')\n  .description('Receive emails via SMTP and expose them via HTTP for testing')\n  .option('-s, --smtpPort <number>', 'SMTP port to listen on', (v) => parseInt(v, 10), 1025)\n  .option('-h, --httpPort <number>', 'HTTP port to listen on', (v) => parseInt(v, 10), 1080)\n  .option('-w, --whitelist <list>', 'Comma-separated list of allowed sender addresses')\n.option('-m, --max <number>', 'Max number of emails to keep in memory', (v) => parseInt(v, 10), 10)\n  .option('--tls', 'Enable TLS for SMTP (STARTTLS is not used; SMTPS only)', false)\n  .option('--tlsKey <path>', 'Path to PEM private key for SMTPS')\n  .option('--tlsCert <path>', 'Path to PEM certificate for SMTPS')\n  .option('--tlsSelfSigned', 'Generate a self-signed cert when TLS is enabled and no key/cert provided', false)\n  .showHelpAfterError(true)\n\nprogram.action(async (opts) => {\n  const whitelist = (opts.whitelist ? String(opts.whitelist).split(',') : []).map((s) => s.trim())\n  await startSink({\n    smtpPort: opts.smtpPort,\n    httpPort: opts.httpPort,\n    whitelist,\n    max: opts.max,\n    tls: !!opts.tls,\n    tlsKeyPath: opts.tlsKey,\n    tlsCertPath: opts.tlsCert,\n    tlsSelfSigned: !!opts.tlsSelfSigned\n  })\n})\n\nprogram.parseAsync(process.argv).catch((err) => {\n  console.error(err)\n  process.exit(1)\n})\n","import http from 'http'\nimport { SMTPServer, SMTPServerSession, SMTPServerAddress } from 'smtp-server'\nimport { simpleParser, ParsedMail } from 'mailparser'\nimport fs from 'fs/promises'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\nimport { generate as generateSelfSigned } from 'selfsigned'\nimport { WebSocketServer, WebSocket } from 'ws'\n\nexport type MailRecord = {\n  id: string\n  to: string | string[]\n  from: string\n  subject?: string\n  text?: string\n  html?: string\n  date: string\n  headers: Record<string, string>\n}\n\nexport type SinkOptions = {\n  smtpPort?: number\n  httpPort?: number\n  whitelist?: string[]\n  max?: number\n  tls?: boolean\n  tlsKeyPath?: string\n  tlsCertPath?: string\n  tlsSelfSigned?: boolean\n}\n\nexport type RunningServers = {\n  smtp: SMTPServer\n  http: http.Server\n  wss: WebSocketServer\n  ports: { smtp: number; http: number }\n  stop: () => Promise<void>\n}\n\nfunction createRingBuffer<T extends { id: string }>(max: number, onChange?: () => void) {\n  let arr: T[] = []\n  return {\n    push(item: T) {\n      arr.push(item)\n      while (arr.length > max) arr.splice(0, 1)\n      onChange?.()\n    },\n    toArray() {\n      return [...arr]\n    },\n    clear() {\n      arr = []\n      onChange?.()\n    },\n    remove(id: string) {\n      const idx = arr.findIndex((item) => item.id === id)\n      if (idx !== -1) {\n        arr.splice(idx, 1)\n        onChange?.()\n        return true\n      }\n      return false\n    }\n  }\n}\n\nexport async function startSink(opts: SinkOptions = {}): Promise<RunningServers> {\n  const smtpPort = opts.smtpPort ?? 1025\n  const httpPort = opts.httpPort ?? 1080\n  const whitelist = (opts.whitelist ?? []).map((s) => s.toLowerCase().trim()).filter(Boolean)\n  const max = opts.max ?? 10\n\n  // WebSocket clients\n  const wsClients = new Set<WebSocket>()\n\n  function broadcast(event: string, data?: unknown) {\n    const msg = JSON.stringify({ event, data })\n    for (const client of wsClients) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(msg)\n      }\n    }\n  }\n\n  const store = createRingBuffer<MailRecord>(max, () => {\n    broadcast('emails', store.toArray())\n  })\n\n  // Load UI (if available) at startup\n  const __filename = fileURLToPath(import.meta.url)\n  const __dirname = path.dirname(__filename)\n  let indexHtml: string | null = null\n  try {\n    const p = path.join(__dirname, '../public/index.html')\n    indexHtml = await fs.readFile(p, 'utf8')\n  } catch {}\n\n  // Prepare TLS options if requested\n  let secure = false\n  let key: Buffer | undefined\n  let cert: Buffer | undefined\n  if (opts.tls) {\n    secure = true\n    if (opts.tlsKeyPath && opts.tlsCertPath) {\n      key = await fs.readFile(opts.tlsKeyPath)\n      cert = await fs.readFile(opts.tlsCertPath)\n    } else if (opts.tlsSelfSigned) {\n      const pems = generateSelfSigned(undefined, { days: 365 })\n      key = Buffer.from(pems.private)\n      cert = Buffer.from(pems.cert)\n    } else {\n      // If TLS requested but no material provided, fall back to self-signed\n      const pems = generateSelfSigned(undefined, { days: 365 })\n      key = Buffer.from(pems.private)\n      cert = Buffer.from(pems.cert)\n    }\n  }\n\n  const smtpServer = new SMTPServer({\n    disabledCommands: ['AUTH'],\n    logger: false,\n    secure,\n    key,\n    cert,\n    onMailFrom(address: SMTPServerAddress, session: SMTPServerSession, callback: (err?: Error | null) => void) {\n      if (whitelist.length === 0) return callback()\n      const from = (address.address || '').toLowerCase()\n      if (from && whitelist.includes(from)) return callback()\n      const err = new Error('Sender not allowed') as any\n      err.responseCode = 550\n      return callback(err)\n    },\n    async onData(stream: NodeJS.ReadableStream, session: SMTPServerSession, callback: (err?: Error | null) => void) {\n      try {\n        const parsed: ParsedMail = await simpleParser(stream as any)\n        const toList = ((): string[] => {\n          const p: any = parsed as any\n          if (p.to && Array.isArray(p.to.value)) {\n            return p.to.value.map((v: any) => v?.address ?? '').filter(Boolean)\n          }\n          const rcpts: any[] = (session.envelope.rcptTo || []) as any[]\n          return rcpts.map((r: any) => (r && r.address) || '').filter(Boolean)\n        })()\n        const fromAddr = (() => {\n          const p: any = parsed as any\n          if (p.from && typeof p.from.text === 'string') return p.from.text\n          const mf: any = session.envelope.mailFrom\n          return (mf && mf.address) || 'unknown'\n        })()\n        const headers = Object.fromEntries(\n          Array.from(((parsed as any).headers as Map<string, any>) || new Map()).map(([k, v]) => [k, String(v)])\n        )\n        const rec: MailRecord = {\n          id: `${Date.now()}-${Math.random().toString(36).slice(2)}`,\n          to: toList,\n          from: fromAddr,\n          subject: parsed.subject || undefined,\n          text: parsed.text || undefined,\n          html: typeof parsed.html === 'string' ? parsed.html : undefined,\n          date: (parsed.date || new Date()).toISOString(),\n          headers\n        }\n        store.push(rec)\n        callback()\n      } catch (err) {\n        callback(err as Error)\n      }\n    }\n  })\n\n  await new Promise<void>((resolve, reject) => {\n    smtpServer.once('error', reject)\n    smtpServer.listen(smtpPort, () => resolve())\n  })\n\n  const httpServer = http.createServer((req, res) => {\n    if (!req.url) {\n      res.writeHead(400, { 'Content-Type': 'text/plain' })\n      res.end('Bad Request')\n      return\n    }\n    if (req.method === 'GET' && (req.url === '/' || req.url === '/index.html')) {\n      if (indexHtml) {\n        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' })\n        res.end(indexHtml)\n      } else {\n        res.writeHead(404, { 'Content-Type': 'text/plain' })\n        res.end('UI not found')\n      }\n      return\n    }\n    if (req.method === 'GET' && req.url === '/emails') {\n      res.writeHead(200, { 'Content-Type': 'application/json' })\n      res.end(JSON.stringify(store.toArray()))\n      return\n    }\n    if (req.method === 'DELETE' && req.url === '/emails') {\n      store.clear()\n      res.writeHead(204)\n      res.end()\n      return\n    }\n    // DELETE /emails/:id - delete single email\n    const deleteMatch = req.method === 'DELETE' && req.url?.match(/^\\/emails\\/([^/]+)$/)\n    if (deleteMatch) {\n      const id = decodeURIComponent(deleteMatch[1])\n      const removed = store.remove(id)\n      if (removed) {\n        res.writeHead(204)\n        res.end()\n      } else {\n        res.writeHead(404, { 'Content-Type': 'text/plain' })\n        res.end('Email not found')\n      }\n      return\n    }\n    res.writeHead(404, { 'Content-Type': 'text/plain' })\n    res.end('Not found')\n  })\n\n  await new Promise<void>((resolve) => {\n    httpServer.listen(httpPort, () => resolve())\n  })\n\n  // WebSocket server attached to HTTP server\n  const wss = new WebSocketServer({ server: httpServer })\n  wss.on('connection', (ws) => {\n    wsClients.add(ws)\n    // Send current emails on connect\n    ws.send(JSON.stringify({ event: 'emails', data: store.toArray() }))\n    ws.on('close', () => wsClients.delete(ws))\n    ws.on('error', () => wsClients.delete(ws))\n  })\n\n  const resolved = {\n    smtp: smtpServer,\n    http: httpServer,\n    wss,\n    ports: {\n      smtp: (smtpServer.server.address() as any)?.port ?? smtpPort,\n      http: (httpServer.address() as any)?.port ?? httpPort\n    },\n    async stop() {\n      wss.close()\n      for (const client of wsClients) client.terminate()\n      await Promise.all([\n        new Promise<void>((resolve) => httpServer.close(() => resolve())),\n        new Promise<void>((resolve) => smtpServer.close(() => resolve()))\n      ])\n    }\n  }\n\n  // eslint-disable-next-line no-console\n  console.info(`SMTP server listening on port ${resolved.ports.smtp}`)\n  // eslint-disable-next-line no-console\n  console.info(`HTTP server listening on port ${resolved.ports.http}, emails at /emails`)\n\n  return resolved\n}\n"],"mappings":"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","names":[]}